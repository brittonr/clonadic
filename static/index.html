<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clonadic</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --surface: #141414;
      --border: #2a2a2a;
      --text: #e0e0e0;
      --text-dim: #666;
      --accent: #3b82f6;
      --error: #ef4444;
      --success: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    .logo span {
      color: var(--accent);
    }

    .actions {
      display: flex;
      gap: 12px;
    }

    button {
      font-family: inherit;
      font-size: 13px;
      padding: 8px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s;
    }

    button:hover {
      background: var(--border);
      border-color: var(--text-dim);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
    }

    button.primary:hover {
      background: #2563eb;
    }

    .formula-bar {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .formula-bar label {
      color: var(--text-dim);
      font-size: 14px;
      font-style: italic;
    }

    .cell-ref {
      background: var(--bg);
      border: 1px solid var(--border);
      padding: 6px 12px;
      min-width: 60px;
      text-align: center;
      font-weight: 600;
      color: var(--accent);
    }

    #formula-input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      padding: 6px 12px;
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }

    #formula-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .spreadsheet-container {
      flex: 1;
      overflow: auto;
      padding: 0;
    }

    .spreadsheet {
      display: grid;
      grid-template-columns: 50px repeat(10, minmax(100px, 1fr));
      min-width: max-content;
    }

    .cell {
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      padding: 8px 12px;
      min-height: 36px;
      font-size: 13px;
      cursor: cell;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .cell:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .cell.selected {
      background: rgba(59, 130, 246, 0.2);
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.in-selection {
      background: rgba(59, 130, 246, 0.15);
    }

    .cell.selection-corner {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.header {
      background: var(--surface);
      color: var(--text-dim);
      font-weight: 600;
      text-align: center;
      cursor: default;
    }

    .cell.header:hover {
      background: var(--surface);
    }

    .cell.row-header {
      background: var(--surface);
      color: var(--text-dim);
      text-align: center;
      font-weight: 600;
      cursor: default;
    }

    .cell.row-header:hover {
      background: var(--surface);
    }

    .cell.formula {
      color: var(--accent);
    }

    .cell.error {
      color: var(--error);
    }

    .cell.boolean {
      color: #a855f7;
      font-weight: 600;
    }

    .cell.text {
      color: var(--success);
    }

    .cell.loading {
      color: var(--text-dim);
      font-style: italic;
    }

    /* Point mode - cells are clickable during formula editing */
    .cell.point-mode {
      cursor: crosshair;
    }

    .cell.point-mode:hover {
      background: rgba(59, 130, 246, 0.3);
      outline: 2px dashed var(--accent);
      outline-offset: -2px;
    }

    .cell.point-mode.self-ref {
      cursor: not-allowed;
    }

    .cell.point-mode.self-ref:hover {
      background: rgba(239, 68, 68, 0.2);
      outline: 2px dashed var(--error);
    }

    /* Formula reference highlighting */
    .cell.formula-ref {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.formula-ref-range {
      background: rgba(59, 130, 246, 0.15);
    }

    /* Point mode indicator in formula bar */
    .formula-bar.point-mode .cell-ref::after {
      content: ' (click cells)';
      font-size: 10px;
      color: var(--accent);
      font-weight: normal;
    }

    .formula-bar.point-mode #formula-input {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
    }

    /* Range selection start marker during point mode */
    .cell.range-start {
      outline: 2px solid var(--success);
      outline-offset: -2px;
    }

    /* Cut/Copy/Move visual feedback */
    .cell.cut-source {
      opacity: 0.5;
      outline: 2px dashed var(--accent);
      outline-offset: -2px;
    }

    .cell.copy-source {
      outline: 2px dashed var(--success);
      outline-offset: -2px;
    }

    .cell.drag-source {
      opacity: 0.4;
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.drop-target {
      background: rgba(59, 130, 246, 0.3);
      outline: 2px dashed var(--accent);
      outline-offset: -2px;
    }

    .cell.drop-target-invalid {
      background: rgba(239, 68, 68, 0.2);
      outline: 2px dashed var(--error);
      outline-offset: -2px;
    }

    /* Drag preview ghost */
    .drag-preview {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      background: var(--surface);
      border: 2px solid var(--accent);
      padding: 4px 8px;
      font-size: 12px;
      opacity: 0.9;
      white-space: nowrap;
    }

    /* Clipboard indicator in footer */
    .clipboard-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--accent);
      font-size: 11px;
    }

    .clipboard-indicator.cut {
      color: var(--error);
    }

    .clipboard-indicator:empty {
      display: none;
    }

    footer {
      background: var(--surface);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }

    .stats {
      display: flex;
      gap: 24px;
      color: var(--text-dim);
    }

    .stat {
      display: flex;
      gap: 6px;
    }

    .stat-value {
      color: var(--text);
    }

    .tagline {
      color: var(--text-dim);
      font-style: italic;
    }

    .loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 24px 32px;
      display: none;
      z-index: 1000;
    }

    .loading-indicator.active {
      display: block;
    }

    .loading-indicator .spinner {
      margin-bottom: 12px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .about-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .about-modal.active {
      display: flex;
    }

    .about-content {
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 32px;
      max-width: 600px;
      width: 90%;
    }

    .about-content h2 {
      margin-bottom: 16px;
      font-size: 20px;
    }

    .about-content p {
      margin-bottom: 12px;
      color: var(--text-dim);
      line-height: 1.6;
    }

    .about-content code {
      background: var(--bg);
      padding: 2px 6px;
      font-size: 13px;
    }

    .about-content .close {
      margin-top: 24px;
    }

    /* Autocomplete dropdown styles */
    .formula-bar {
      position: relative;
    }

    .autocomplete-container {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-top: none;
      max-height: 280px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .autocomplete-dropdown.active {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 2px;
      border-bottom: 1px solid var(--border);
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(59, 130, 246, 0.2);
    }

    .autocomplete-item.selected {
      outline: 1px solid var(--accent);
      outline-offset: -1px;
    }

    .autocomplete-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .autocomplete-text {
      font-weight: 600;
      color: var(--text);
    }

    .autocomplete-type {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .autocomplete-type.function {
      background: rgba(59, 130, 246, 0.3);
      color: var(--accent);
    }

    .autocomplete-type.cell {
      background: rgba(34, 197, 94, 0.3);
      color: var(--success);
    }

    .autocomplete-type.range {
      background: rgba(168, 85, 247, 0.3);
      color: #a855f7;
    }

    .autocomplete-desc {
      font-size: 12px;
      color: var(--text-dim);
    }

    .autocomplete-hint {
      padding: 6px 12px;
      font-size: 11px;
      color: var(--text-dim);
      background: var(--bg);
      border-top: 1px solid var(--border);
    }

    /* Context Menu Styles */
    .context-menu {
      position: fixed;
      z-index: 2000;
      background: var(--surface);
      border: 1px solid var(--border);
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      display: none;
      padding: 4px 0;
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--text);
      transition: background 0.1s;
    }

    .context-menu-item:hover {
      background: rgba(59, 130, 246, 0.2);
    }

    .context-menu-item.disabled {
      color: var(--text-dim);
      cursor: not-allowed;
    }

    .context-menu-item.disabled:hover {
      background: transparent;
    }

    .context-menu-item .shortcut {
      color: var(--text-dim);
      font-size: 11px;
      margin-left: 24px;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    .context-menu-submenu {
      position: relative;
    }

    .context-menu-submenu::after {
      content: '\25B6';
      font-size: 8px;
      color: var(--text-dim);
    }

    .context-menu-submenu .context-submenu {
      position: absolute;
      left: 100%;
      top: -4px;
      background: var(--surface);
      border: 1px solid var(--border);
      min-width: 160px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      display: none;
      padding: 4px 0;
    }

    .context-menu-submenu:hover .context-submenu {
      display: block;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">Clon<span>adic</span></div>
    <div class="actions">
      <button onclick="recalculateAll()">Recalculate All</button>
      <button onclick="showAbout()">About</button>
    </div>
  </header>

  <div class="formula-bar">
    <label>fx</label>
    <div class="cell-ref" id="cell-ref">A1</div>
    <div class="autocomplete-container">
      <input type="text" id="formula-input" placeholder="Enter a value or formula (=... then click cells to insert references)" autocomplete="off">
      <div class="autocomplete-dropdown" id="autocomplete-dropdown">
        <div class="autocomplete-hint">Type = to start a formula, then type function names or cell references</div>
      </div>
    </div>
    <button onclick="submitFormula()">Enter</button>
  </div>

  <div class="spreadsheet-container">
    <div class="spreadsheet" id="spreadsheet">
      <!-- Header row -->
      <div class="cell header"></div>
      <div class="cell header">A</div>
      <div class="cell header">B</div>
      <div class="cell header">C</div>
      <div class="cell header">D</div>
      <div class="cell header">E</div>
      <div class="cell header">F</div>
      <div class="cell header">G</div>
      <div class="cell header">H</div>
      <div class="cell header">I</div>
      <div class="cell header">J</div>

      <!-- Data rows will be generated by JS -->
    </div>
  </div>

  <footer>
    <div class="stats">
      <div class="stat">Claude operations: <span class="stat-value" id="stat-ops">0</span></div>
      <div class="stat">Tokens: <span class="stat-value" id="stat-tokens">~0</span></div>
      <div class="stat">Est. cost: <span class="stat-value" id="stat-cost">~$0.00</span></div>
    </div>
    <div class="tagline">"Every formula evaluation is a prayer."</div>
  </footer>

  <div class="loading-indicator" id="loading">
    <div class="spinner">Claude is computing...</div>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="context-menu">
    <div class="context-menu-item" data-action="cut">
      <span>Cut</span>
      <span class="shortcut">Ctrl+X</span>
    </div>
    <div class="context-menu-item" data-action="copy">
      <span>Copy</span>
      <span class="shortcut">Ctrl+C</span>
    </div>
    <div class="context-menu-item" data-action="paste">
      <span>Paste</span>
      <span class="shortcut">Ctrl+V</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="clear">
      <span>Clear Contents</span>
      <span class="shortcut">Del</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item context-menu-submenu" data-action="insert">
      <span>Insert</span>
      <div class="context-submenu">
        <div class="context-menu-item" data-action="insert-row-above">Insert Row Above</div>
        <div class="context-menu-item" data-action="insert-row-below">Insert Row Below</div>
        <div class="context-menu-item" data-action="insert-col-left">Insert Column Left</div>
        <div class="context-menu-item" data-action="insert-col-right">Insert Column Right</div>
      </div>
    </div>
    <div class="context-menu-item context-menu-submenu" data-action="delete">
      <span>Delete</span>
      <div class="context-submenu">
        <div class="context-menu-item" data-action="delete-row">Delete Row</div>
        <div class="context-menu-item" data-action="delete-col">Delete Column</div>
      </div>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="select-row">
      <span>Select Row</span>
    </div>
    <div class="context-menu-item" data-action="select-col">
      <span>Select Column</span>
    </div>
    <div class="context-menu-item" data-action="select-all">
      <span>Select All</span>
      <span class="shortcut">Ctrl+A</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="recalculate">
      <span>Recalculate Cell</span>
    </div>
  </div>

  <div class="about-modal" id="about-modal">
    <div class="about-content">
      <h2>Clonadic</h2>
      <p>A spreadsheet where Claude evaluates every formula.</p>
      <p>
        <code>=2+2</code> is a Claude API call.<br>
        <code>=SUM(A1:A5)</code> is a Claude API call.<br>
        <code>=A1*B1</code> is a Claude API call.
      </p>
      <p>
        Spreadsheet formulas are the bedrock of financial modeling.
        They must be deterministic. Same input, same output. Always.
      </p>
      <p>
        This spreadsheet uses a large language model to compute
        <code>=A1+B1</code>.
      </p>
      <p style="margin-top: 24px; font-style: italic;">
        "We did this because we could."
        <br>
        <span style="color: var(--text-dim);">- Jane Street Hackathon 2026</span>
      </p>
      <button class="close" onclick="hideAbout()">Close</button>
    </div>
  </div>

  <script>
    const ROWS = 20, COLS = 10, DELIM = '(),+-*/^&=<>: ';

    let selectedCell = { row: 1, col: 1 }, cells = {}, selectedRange = null;
    let isDragging = false, dragStart = null, dragEnd = null;
    let autocompleteSelectedIndex = -1, autocompleteSuggestions = [], autocompleteDebounceTimer = null;
    let isInPointMode = false, pointModeRangeStart = null, pointModeNavPosition = null;
    let clipboard = null, isDragToMove = false, dragMoveStart = null;
    let contextMenuCell = null;

    const $ = id => document.getElementById(id);
    const $$ = sel => document.querySelectorAll(sel);

    function colToLetter(c) {
      let r = '';
      while (c > 0) { c--; r = String.fromCharCode(65 + c % 26) + r; c = Math.floor(c / 26); }
      return r;
    }

    function letterToCol(s) {
      let c = 0;
      for (let i = 0; i < s.length; i++) c = c * 26 + s.charCodeAt(i) - 64;
      return c;
    }

    function parseRef(ref) {
      const m = ref.match(/^([A-Z]+)(\d+)$/);
      if (!m) return null;
      const col = letterToCol(m[1]), row = parseInt(m[2]);
      return (row > 0 && row <= ROWS && col > 0 && col <= COLS) ? { row, col } : null;
    }

    function getCellElement(row, col) {
      return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }

    function findLastDelim(s) {
      for (let i = s.length - 1; i >= 0; i--) if (DELIM.includes(s[i])) return i;
      return -1;
    }

    function tokenize(s) {
      const tokens = []; let cur = '';
      for (const c of s) { if (DELIM.includes(c)) { if (cur) tokens.push(cur); cur = ''; } else cur += c; }
      if (cur) tokens.push(cur);
      return tokens;
    }

    function normalizeBounds(r1, c1, r2, c2) {
      return { startRow: Math.min(r1, r2), startCol: Math.min(c1, c2), endRow: Math.max(r1, r2), endCol: Math.max(c1, c2) };
    }

    function init() {
      renderGrid();
      selectCell(1, 1);
      loadGrid();
      setupAutocomplete();
      setupPointMode();
      setupContextMenu();
      document.addEventListener('keydown', handleClipboardKeydown);
    }

    function setupAutocomplete() {
      const input = $('formula-input'), dropdown = $('autocomplete-dropdown');
      input.addEventListener('keydown', e => {
        if (dropdown.classList.contains('active') && autocompleteSuggestions.length > 0) {
          if (e.key === 'ArrowDown') { e.preventDefault(); autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, autocompleteSuggestions.length - 1); updateAutocompleteSelection(); return; }
          if (e.key === 'ArrowUp') { e.preventDefault(); autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, 0); updateAutocompleteSelection(); return; }
          if (e.key === 'Tab' && autocompleteSelectedIndex >= 0) { e.preventDefault(); applyAutocompleteSuggestion(autocompleteSelectedIndex); return; }
          if (e.key === 'Escape') { hideAutocomplete(); return; }
        }
        if (e.key === 'Enter') { hideAutocomplete(); submitFormula(); }
      });
      input.addEventListener('input', () => { clearTimeout(autocompleteDebounceTimer); autocompleteDebounceTimer = setTimeout(() => fetchAutocompleteSuggestions(input.value), 100); });
      input.addEventListener('blur', () => setTimeout(hideAutocomplete, 150));
      input.addEventListener('focus', () => { if (input.value.startsWith('=')) fetchAutocompleteSuggestions(input.value); });
      document.addEventListener('click', e => { if (!e.target.closest('.autocomplete-container')) hideAutocomplete(); });
    }

    function setupPointMode() {
      const input = $('formula-input');
      input.addEventListener('input', updatePointMode);
      input.addEventListener('focus', updatePointMode);
      input.addEventListener('blur', () => setTimeout(exitPointMode, 100));
    }

    function updatePointMode() {
      const input = $('formula-input'), val = input.value, was = isInPointMode;
      isInPointMode = val.startsWith('=') && document.activeElement === input;
      if (isInPointMode !== was) isInPointMode ? enterPointMode() : exitPointMode();
      if (isInPointMode) highlightFormulaReferences(val);
    }

    function enterPointMode() {
      isInPointMode = true; pointModeRangeStart = null;
      document.querySelector('.formula-bar').classList.add('point-mode');
      $$('.cell:not(.header):not(.row-header)').forEach(cell => {
        cell.classList.add('point-mode');
        if (+cell.dataset.row === selectedCell.row && +cell.dataset.col === selectedCell.col) cell.classList.add('self-ref');
      });
    }

    function exitPointMode() {
      isInPointMode = false; pointModeRangeStart = null; pointModeNavPosition = null;
      document.querySelector('.formula-bar').classList.remove('point-mode');
      $$('.cell.point-mode').forEach(c => c.classList.remove('point-mode', 'self-ref', 'range-start'));
      clearFormulaRefHighlights();
    }

    function insertCellReference(row, col, isShift = false) {
      const input = $('formula-input'), ref = colToLetter(col) + row;
      if (isShift && pointModeRangeStart) {
        insertAtCursor(input, `${colToLetter(pointModeRangeStart.col)}${pointModeRangeStart.row}:${ref}`, true);
        pointModeRangeStart = null;
        $$('.cell.range-start').forEach(c => c.classList.remove('range-start'));
      } else {
        insertAtCursor(input, ref, false);
        pointModeRangeStart = { row, col };
        $$('.cell.range-start').forEach(c => c.classList.remove('range-start'));
        const el = getCellElement(row, col); if (el) el.classList.add('range-start');
      }
      input.focus(); highlightFormulaReferences(input.value);
    }

    function insertAtCursor(input, text, replaceLastRef) {
      const start = input.selectionStart, end = input.selectionEnd, val = input.value;
      let newVal, pos;
      if (replaceLastRef) {
        const before = val.substring(0, start), after = val.substring(end), idx = findLastDelim(before);
        newVal = before.substring(0, idx + 1) + text + after; pos = idx + 1 + text.length;
      } else if (start !== end) {
        newVal = val.substring(0, start) + text + val.substring(end); pos = start + text.length;
      } else {
        const before = val.substring(0, start), after = val.substring(start);
        const lastChar = before.length > 0 ? before[before.length - 1] : '=';
        if (DELIM.includes(lastChar)) { newVal = before + text + after; pos = start + text.length; }
        else {
          let ts = before.length; for (let i = before.length - 1; i >= 0; i--) { if (DELIM.includes(before[i])) { ts = i + 1; break; } if (i === 0) ts = 0; }
          let te = start; for (let i = 0; i < after.length; i++) { if (DELIM.includes(after[i])) break; te++; }
          newVal = val.substring(0, ts) + text + val.substring(te); pos = ts + text.length;
        }
      }
      input.value = newVal; input.setSelectionRange(pos, pos);
    }

    function highlightFormulaReferences(formula) {
      clearFormulaRefHighlights();
      if (!formula.startsWith('=')) return;
      extractRefsFromFormula(formula).forEach(ref => {
        if (ref.type === 'single') { const el = getCellElement(ref.row, ref.col); if (el) el.classList.add('formula-ref'); }
        else for (let r = ref.startRow; r <= ref.endRow; r++) for (let c = ref.startCol; c <= ref.endCol; c++) { const el = getCellElement(r, c); if (el) el.classList.add('formula-ref', 'formula-ref-range'); }
      });
    }

    function extractRefsFromFormula(formula) {
      const refs = [];
      tokenize(formula).forEach(token => {
        const upper = token.toUpperCase();
        if (upper.includes(':')) {
          const [a, b] = upper.split(':'), s = parseRef(a), e = parseRef(b);
          if (s && e) refs.push({ type: 'range', ...normalizeBounds(s.row, s.col, e.row, e.col) });
        } else { const p = parseRef(upper); if (p) refs.push({ type: 'single', ...p }); }
      });
      return refs;
    }

    function clearFormulaRefHighlights() { $$('.cell.formula-ref, .cell.formula-ref-range').forEach(c => c.classList.remove('formula-ref', 'formula-ref-range')); }

    function handleClipboardKeydown(e) {
      if (document.activeElement.id === 'formula-input') return;
      const mod = e.ctrlKey || e.metaKey;
      if (mod && e.key === 'x') { e.preventDefault(); cutSelectedCells(); }
      else if (mod && e.key === 'c') { e.preventDefault(); copySelectedCells(); }
      else if (mod && e.key === 'v') { e.preventDefault(); pasteClipboard(); }
      else if (mod && e.key === 'a') { e.preventDefault(); selectAll(); }
      else if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); clearSelectedCells(); }
    }

    function getCellDataForClipboard(row, col) {
      const d = cells[`${row},${col}`] || {};
      return { row, col, value: d.formula || d.display || '', formula: d.formula || null };
    }

    function cutSelectedCells() {
      const sel = getSelectedCells(); if (!sel.length) return;
      clipboard = { cells: sel.map(({ row, col }) => getCellDataForClipboard(row, col)), mode: 'cut', sourceRange: getSelectionBounds() };
      clearClipboardVisuals();
      sel.forEach(({ row, col }) => { const el = getCellElement(row, col); if (el) el.classList.add('cut-source'); });
    }

    function copySelectedCells() {
      const sel = getSelectedCells(); if (!sel.length) return;
      clipboard = { cells: sel.map(({ row, col }) => getCellDataForClipboard(row, col)), mode: 'copy', sourceRange: getSelectionBounds() };
      clearClipboardVisuals();
      sel.forEach(({ row, col }) => { const el = getCellElement(row, col); if (el) el.classList.add('copy-source'); });
    }

    async function pasteClipboard() {
      if (!clipboard?.cells.length) return;
      const { startRow: sr, startCol: sc } = clipboard.sourceRange;
      const ro = selectedCell.row - sr, co = selectedCell.col - sc;
      showLoading();
      try {
        for (const d of clipboard.cells) {
          const nr = d.row + ro, nc = d.col + co;
          if (nr >= 1 && nr <= ROWS && nc >= 1 && nc <= COLS) {
            await updateCellOnServer(nr, nc, clipboard.mode === 'copy' && d.formula ? adjustFormulaReferences(d.formula, ro, co) : d.value);
          }
        }
        if (clipboard.mode === 'cut') {
          for (const d of clipboard.cells) if (d.row !== d.row + ro || d.col !== d.col + co) await updateCellOnServer(d.row, d.col, '');
          clipboard = null;
        }
        await loadGrid();
      } catch (e) { console.error('Paste error:', e); }
      hideLoading(); clearClipboardVisuals();
    }

    async function clearSelectedCells() {
      const sel = getSelectedCells(); if (!sel.length) return;
      showLoading();
      try { for (const { row, col } of sel) await updateCellOnServer(row, col, ''); await loadGrid(); }
      catch (e) { console.error('Clear error:', e); }
      hideLoading();
    }

    async function updateCellOnServer(row, col, value) {
      return (await fetch('/api/cell', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ row, col, value }) })).json();
    }

    function adjustFormulaReferences(formula, ro, co) {
      if (!formula.startsWith('=')) return formula;
      let result = '', cur = '';
      for (const c of formula) {
        if (DELIM.includes(c)) { if (cur) { result += adjustToken(cur, ro, co); cur = ''; } result += c; }
        else cur += c;
      }
      if (cur) result += adjustToken(cur, ro, co);
      return result;
    }

    function adjustToken(token, ro, co) {
      const upper = token.toUpperCase();
      if (upper.includes(':')) {
        const [a, b] = token.split(':'), adj1 = adjustSingleRef(a, ro, co), adj2 = adjustSingleRef(b, ro, co);
        return (adj1 && adj2) ? adj1 + ':' + adj2 : token;
      }
      return adjustSingleRef(token, ro, co) || token;
    }

    function adjustSingleRef(ref, ro, co) {
      const m = ref.toUpperCase().match(/^([A-Z]+)(\d+)$/);
      if (!m) return null;
      const nr = parseInt(m[2]) + ro, nc = letterToCol(m[1]) + co;
      return (nr >= 1 && nr <= ROWS && nc >= 1 && nc <= COLS) ? colToLetter(nc) + nr : '#REF!';
    }

    function getSelectionBounds() {
      return selectedRange || { startRow: selectedCell.row, startCol: selectedCell.col, endRow: selectedCell.row, endCol: selectedCell.col };
    }

    function clearClipboardVisuals() { $$('.cell.cut-source, .cell.copy-source, .cell.drag-source, .cell.drop-target').forEach(c => c.classList.remove('cut-source', 'copy-source', 'drag-source', 'drop-target', 'drop-target-invalid')); }

    // Context Menu Functions
    function setupContextMenu() {
      const menu = $('context-menu');

      // Close menu on click outside
      document.addEventListener('click', e => {
        if (!e.target.closest('.context-menu')) hideContextMenu();
      });

      // Close menu on escape
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape') hideContextMenu();
      });

      // Close menu on scroll
      document.querySelector('.spreadsheet-container').addEventListener('scroll', hideContextMenu);

      // Handle menu item clicks
      menu.addEventListener('click', e => {
        const item = e.target.closest('.context-menu-item');
        if (!item || item.classList.contains('disabled')) return;

        const action = item.dataset.action;
        if (!action || action === 'insert' || action === 'delete') return; // Skip submenu triggers

        handleContextMenuAction(action);
        hideContextMenu();
      });
    }

    function showContextMenu(e, row, col) {
      e.preventDefault();

      // Store the cell that was right-clicked
      contextMenuCell = { row, col };

      // If clicking outside current selection, select the clicked cell
      if (!isCoordInSelection(row, col)) {
        selectedRange = null;
        clearSelectionVisual();
        selectCell(row, col);
      }

      const menu = $('context-menu');

      // Update menu item states
      updateContextMenuState();

      // Calculate position
      let x = e.clientX, y = e.clientY;

      // Ensure menu stays within viewport
      const menuWidth = 180, menuHeight = menu.offsetHeight || 300;
      if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 8;
      if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 8;
      if (x < 0) x = 8;
      if (y < 0) y = 8;

      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      menu.classList.add('active');
    }

    function hideContextMenu() {
      $('context-menu').classList.remove('active');
      contextMenuCell = null;
    }

    function updateContextMenuState() {
      const menu = $('context-menu');
      const pasteItem = menu.querySelector('[data-action="paste"]');

      // Disable paste if no clipboard content
      if (pasteItem) {
        if (!clipboard?.cells.length) {
          pasteItem.classList.add('disabled');
        } else {
          pasteItem.classList.remove('disabled');
        }
      }
    }

    async function handleContextMenuAction(action) {
      switch (action) {
        case 'cut':
          cutSelectedCells();
          break;
        case 'copy':
          copySelectedCells();
          break;
        case 'paste':
          await pasteClipboard();
          break;
        case 'clear':
          await clearSelectedCells();
          break;
        case 'select-row':
          selectRow(contextMenuCell?.row || selectedCell.row);
          break;
        case 'select-col':
          selectColumn(contextMenuCell?.col || selectedCell.col);
          break;
        case 'select-all':
          selectAll();
          break;
        case 'insert-row-above':
          await insertRow(contextMenuCell?.row || selectedCell.row, 'above');
          break;
        case 'insert-row-below':
          await insertRow(contextMenuCell?.row || selectedCell.row, 'below');
          break;
        case 'insert-col-left':
          await insertColumn(contextMenuCell?.col || selectedCell.col, 'left');
          break;
        case 'insert-col-right':
          await insertColumn(contextMenuCell?.col || selectedCell.col, 'right');
          break;
        case 'delete-row':
          await deleteRow(contextMenuCell?.row || selectedCell.row);
          break;
        case 'delete-col':
          await deleteColumn(contextMenuCell?.col || selectedCell.col);
          break;
        case 'recalculate':
          await recalculateCell(contextMenuCell?.row || selectedCell.row, contextMenuCell?.col || selectedCell.col);
          break;
      }
    }

    function selectRow(row) {
      selectedRange = { startRow: row, startCol: 1, endRow: row, endCol: COLS };
      selectedCell = { row, col: 1 };
      clearSelectionVisual();
      dragStart = { row: selectedRange.startRow, col: selectedRange.startCol };
      dragEnd = { row: selectedRange.endRow, col: selectedRange.endCol };
      updateSelectionVisual();
      dragStart = dragEnd = null;
      updateCellRefDisplay();
    }

    function selectColumn(col) {
      selectedRange = { startRow: 1, startCol: col, endRow: ROWS, endCol: col };
      selectedCell = { row: 1, col };
      clearSelectionVisual();
      dragStart = { row: selectedRange.startRow, col: selectedRange.startCol };
      dragEnd = { row: selectedRange.endRow, col: selectedRange.endCol };
      updateSelectionVisual();
      dragStart = dragEnd = null;
      updateCellRefDisplay();
    }

    function selectAll() {
      selectedRange = { startRow: 1, startCol: 1, endRow: ROWS, endCol: COLS };
      selectedCell = { row: 1, col: 1 };
      clearSelectionVisual();
      dragStart = { row: selectedRange.startRow, col: selectedRange.startCol };
      dragEnd = { row: selectedRange.endRow, col: selectedRange.endCol };
      updateSelectionVisual();
      dragStart = dragEnd = null;
      updateCellRefDisplay();
    }

    async function insertRow(targetRow, position) {
      showLoading();
      try {
        const insertAt = position === 'below' ? targetRow + 1 : targetRow;
        // Shift all rows down from insertAt to ROWS
        for (let r = ROWS; r >= insertAt; r--) {
          for (let c = 1; c <= COLS; c++) {
            const d = cells[`${r},${c}`];
            if (d && (d.display || d.formula)) {
              await updateCellOnServer(r + 1, c, d.formula || d.display || '');
            }
          }
        }
        // Clear the inserted row
        for (let c = 1; c <= COLS; c++) {
          await updateCellOnServer(insertAt, c, '');
        }
        await loadGrid();
      } catch (e) { console.error('Insert row error:', e); }
      hideLoading();
    }

    async function insertColumn(targetCol, position) {
      showLoading();
      try {
        const insertAt = position === 'right' ? targetCol + 1 : targetCol;
        // Shift all columns right from insertAt to COLS
        for (let c = COLS; c >= insertAt; c--) {
          for (let r = 1; r <= ROWS; r++) {
            const d = cells[`${r},${c}`];
            if (d && (d.display || d.formula)) {
              await updateCellOnServer(r, c + 1, d.formula || d.display || '');
            }
          }
        }
        // Clear the inserted column
        for (let r = 1; r <= ROWS; r++) {
          await updateCellOnServer(r, insertAt, '');
        }
        await loadGrid();
      } catch (e) { console.error('Insert column error:', e); }
      hideLoading();
    }

    async function deleteRow(targetRow) {
      showLoading();
      try {
        // Shift all rows up from targetRow+1 to ROWS
        for (let r = targetRow; r < ROWS; r++) {
          for (let c = 1; c <= COLS; c++) {
            const d = cells[`${r + 1},${c}`];
            await updateCellOnServer(r, c, d?.formula || d?.display || '');
          }
        }
        // Clear the last row
        for (let c = 1; c <= COLS; c++) {
          await updateCellOnServer(ROWS, c, '');
        }
        await loadGrid();
      } catch (e) { console.error('Delete row error:', e); }
      hideLoading();
    }

    async function deleteColumn(targetCol) {
      showLoading();
      try {
        // Shift all columns left from targetCol+1 to COLS
        for (let c = targetCol; c < COLS; c++) {
          for (let r = 1; r <= ROWS; r++) {
            const d = cells[`${r},${c + 1}`];
            await updateCellOnServer(r, c, d?.formula || d?.display || '');
          }
        }
        // Clear the last column
        for (let r = 1; r <= ROWS; r++) {
          await updateCellOnServer(r, COLS, '');
        }
        await loadGrid();
      } catch (e) { console.error('Delete column error:', e); }
      hideLoading();
    }

    async function recalculateCell(row, col) {
      const d = cells[`${row},${col}`];
      if (!d?.formula) return;
      showLoading();
      try {
        await updateCellOnServer(row, col, d.formula);
        await loadGrid();
      } catch (e) { console.error('Recalculate error:', e); }
      hideLoading();
    }

    function startDragToMove(e, row, col) {
      if (!isCoordInSelection(row, col)) return false;
      isDragToMove = true; dragMoveStart = { row, col };
      getSelectedCells().forEach(({ row, col }) => { const el = getCellElement(row, col); if (el) el.classList.add('drag-source'); });
      return true;
    }

    function updateDragToMoveTarget(row, col) {
      if (!isDragToMove) return;
      $$('.cell.drop-target, .cell.drop-target-invalid').forEach(c => c.classList.remove('drop-target', 'drop-target-invalid'));
      const b = getSelectionBounds(), ro = row - dragMoveStart.row, co = col - dragMoveStart.col;
      const ns = b.startRow + ro, nc = b.startCol + co, ne = b.endRow + ro, nce = b.endCol + co;
      const valid = ns >= 1 && ne <= ROWS && nc >= 1 && nce <= COLS;
      for (let r = ns; r <= ne; r++) for (let c = nc; c <= nce; c++) { const el = getCellElement(r, c); if (el) el.classList.add(valid ? 'drop-target' : 'drop-target-invalid'); }
    }

    async function completeDragToMove(row, col) {
      if (!isDragToMove) return;
      isDragToMove = false;
      const b = getSelectionBounds(), ro = row - dragMoveStart.row, co = col - dragMoveStart.col;
      if (ro === 0 && co === 0) { clearClipboardVisuals(); dragMoveStart = null; return; }
      const ns = b.startRow + ro, nc = b.startCol + co, ne = b.endRow + ro, nce = b.endCol + co;
      if (ns < 1 || ne > ROWS || nc < 1 || nce > COLS) { clearClipboardVisuals(); dragMoveStart = null; return; }
      showLoading();
      try {
        const toMove = getSelectedCells().map(({ row, col }) => getCellDataForClipboard(row, col));
        for (const d of toMove) await updateCellOnServer(d.row + ro, d.col + co, d.value);
        for (const d of toMove) if (!toMove.some(c => c.row + ro === d.row && c.col + co === d.col)) await updateCellOnServer(d.row, d.col, '');
        await loadGrid();
        selectCell(selectedCell.row + ro, selectedCell.col + co);
      } catch (e) { console.error('Drag error:', e); }
      hideLoading(); clearClipboardVisuals(); dragMoveStart = null;
    }

    function isCoordInSelection(row, col) {
      if (selectedRange) return row >= selectedRange.startRow && row <= selectedRange.endRow && col >= selectedRange.startCol && col <= selectedRange.endCol;
      return row === selectedCell.row && col === selectedCell.col;
    }

    async function fetchAutocompleteSuggestions(input) {
      if (!input.startsWith('=')) { hideAutocomplete(); return; }
      try {
        const data = await (await fetch(`/api/autocomplete?input=${encodeURIComponent(input)}`)).json();
        autocompleteSuggestions = data.suggestions || [];
        autocompleteSelectedIndex = autocompleteSuggestions.length > 0 ? 0 : -1;
        renderAutocompleteDropdown();
      } catch (e) { console.error('Autocomplete error:', e); hideAutocomplete(); }
    }

    function renderAutocompleteDropdown() {
      const dropdown = $('autocomplete-dropdown');
      if (!autocompleteSuggestions.length) { dropdown.innerHTML = '<div class="autocomplete-hint">Type function names (SUM, IF, AVERAGE) or cell references (A1, B2)</div>'; dropdown.classList.add('active'); return; }
      dropdown.innerHTML = autocompleteSuggestions.map((s, i) => {
        const tc = s.suggestionType === 'SuggestionFunction' ? 'function' : s.suggestionType === 'SuggestionCell' ? 'cell' : 'range';
        const tl = s.suggestionType === 'SuggestionFunction' ? 'fn' : s.suggestionType === 'SuggestionCell' ? 'cell' : 'range';
        return `<div class="autocomplete-item${i === autocompleteSelectedIndex ? ' selected' : ''}" onclick="applyAutocompleteSuggestion(${i})"><div class="autocomplete-main"><span class="autocomplete-text">${escapeHtml(s.suggestionDisplay)}</span><span class="autocomplete-type ${tc}">${tl}</span></div><div class="autocomplete-desc">${escapeHtml(s.suggestionDescription)}</div></div>`;
      }).join('') + '<div class="autocomplete-hint">Tab to fill, Enter to submit, Esc to close</div>';
      dropdown.classList.add('active');
    }

    function updateAutocompleteSelection() {
      $$('.autocomplete-item').forEach((el, i) => { el.classList.toggle('selected', i === autocompleteSelectedIndex); if (i === autocompleteSelectedIndex) el.scrollIntoView({ block: 'nearest' }); });
    }

    function applyAutocompleteSuggestion(i) {
      if (i < 0 || i >= autocompleteSuggestions.length) return;
      const s = autocompleteSuggestions[i], input = $('formula-input');
      const idx = findLastDelim(input.value);
      input.value = (idx === -1 ? '' : input.value.substring(0, idx + 1)) + s.suggestionInsert;
      input.focus(); hideAutocomplete();
      if (s.suggestionType === 'SuggestionFunction') setTimeout(() => fetchAutocompleteSuggestions(input.value), 50);
    }

    function hideAutocomplete() { $('autocomplete-dropdown').classList.remove('active'); autocompleteSelectedIndex = -1; autocompleteSuggestions = []; }
    function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

    function renderGrid() {
      const sheet = $('spreadsheet');
      $$('.cell:not(.header)').forEach(c => { if (!c.classList.contains('header')) c.remove(); });
      for (let row = 1; row <= ROWS; row++) {
        const rh = document.createElement('div'); rh.className = 'cell row-header'; rh.textContent = row; sheet.appendChild(rh);
        for (let col = 1; col <= COLS; col++) {
          const cell = document.createElement('div'); cell.className = 'cell'; cell.dataset.row = row; cell.dataset.col = col;
          cell.onmousedown = e => handleCellMouseDown(e, row, col);
          cell.onmouseenter = e => handleCellMouseEnter(e, row, col);
          cell.ondblclick = () => editCell(row, col);
          cell.oncontextmenu = e => showContextMenu(e, row, col);
          sheet.appendChild(cell);
        }
      }
      document.addEventListener('mouseup', handleMouseUp);
    }

    function handleCellMouseDown(e, row, col) {
      e.preventDefault();
      if (isInPointMode) { if (row !== selectedCell.row || col !== selectedCell.col) insertCellReference(row, col, e.shiftKey); return; }
      if (isCoordInSelection(row, col) && !e.shiftKey && startDragToMove(e, row, col)) { isDragging = true; dragStart = dragEnd = { row, col }; return; }
      clearClipboardVisuals();
      isDragging = true; dragStart = dragEnd = { row, col }; selectedRange = null;
      selectCell(row, col);
    }

    function handleCellMouseEnter(e, row, col) {
      if (isInPointMode && isDragging && dragStart) { dragEnd = { row, col }; updatePointModeRangeVisual(); return; }
      if (isDragToMove && isDragging) { dragEnd = { row, col }; updateDragToMoveTarget(row, col); return; }
      if (!isDragging || !dragStart) return;
      dragEnd = { row, col }; updateSelectionVisual();
    }

    function handleMouseUp() {
      if (!isDragging) return;
      if (isDragToMove && dragEnd) { isDragging = false; completeDragToMove(dragEnd.row, dragEnd.col); dragStart = dragEnd = null; return; }
      if (isInPointMode && dragStart && dragEnd) {
        isDragging = false;
        const b = normalizeBounds(dragStart.row, dragStart.col, dragEnd.row, dragEnd.col);
        if (b.startRow !== b.endRow || b.startCol !== b.endCol) {
          const input = $('formula-input');
          insertAtCursor(input, `${colToLetter(b.startCol)}${b.startRow}:${colToLetter(b.endCol)}${b.endRow}`, true);
          input.focus(); highlightFormulaReferences(input.value);
        }
        dragStart = dragEnd = null; return;
      }
      isDragging = false;
      if (dragStart && dragEnd) {
        const b = normalizeBounds(dragStart.row, dragStart.col, dragEnd.row, dragEnd.col);
        selectedRange = (b.startRow !== b.endRow || b.startCol !== b.endCol) ? b : null;
        if (selectedRange) updateCellRefDisplay();
      }
    }

    function updatePointModeRangeVisual() {
      clearFormulaRefHighlights();
      if (!dragStart || !dragEnd) return;
      const b = normalizeBounds(dragStart.row, dragStart.col, dragEnd.row, dragEnd.col);
      for (let r = b.startRow; r <= b.endRow; r++) for (let c = b.startCol; c <= b.endCol; c++) { const el = getCellElement(r, c); if (el) el.classList.add('formula-ref', 'formula-ref-range'); }
    }

    function updateSelectionVisual() {
      $$('.cell.in-selection, .cell.selection-corner').forEach(c => c.classList.remove('in-selection', 'selection-corner'));
      if (!dragStart || !dragEnd) return;
      const b = normalizeBounds(dragStart.row, dragStart.col, dragEnd.row, dragEnd.col);
      for (let r = b.startRow; r <= b.endRow; r++) for (let c = b.startCol; c <= b.endCol; c++) { const el = getCellElement(r, c); if (el) el.classList.add('in-selection'); }
      const corner = getCellElement(b.endRow, b.endCol); if (corner) corner.classList.add('selection-corner');
      if (b.startRow !== b.endRow || b.startCol !== b.endCol) $('cell-ref').textContent = `${colToLetter(b.startCol)}${b.startRow}:${colToLetter(b.endCol)}${b.endRow}`;
    }

    function updateCellRefDisplay() {
      if (selectedRange) $('cell-ref').textContent = `${colToLetter(selectedRange.startCol)}${selectedRange.startRow}:${colToLetter(selectedRange.endCol)}${selectedRange.endRow}`;
      else $('cell-ref').textContent = colToLetter(selectedCell.col) + selectedCell.row;
    }

    function clearSelectionVisual() { $$('.cell.in-selection, .cell.selection-corner').forEach(c => c.classList.remove('in-selection', 'selection-corner')); }

    function getSelectedCells() {
      if (!selectedRange) return [{ row: selectedCell.row, col: selectedCell.col }];
      const r = [];
      for (let row = selectedRange.startRow; row <= selectedRange.endRow; row++) for (let col = selectedRange.startCol; col <= selectedRange.endCol; col++) r.push({ row, col });
      return r;
    }

    function selectCell(row, col, clearRange = true) {
      $$('.cell.selected').forEach(c => c.classList.remove('selected'));
      if (clearRange) { selectedRange = null; clearSelectionVisual(); }
      selectedCell = { row, col };
      const cell = getCellElement(row, col); if (cell) cell.classList.add('selected');
      $('cell-ref').textContent = colToLetter(col) + row;
      const d = cells[`${row},${col}`], input = $('formula-input');
      input.value = d?.formula || d?.display || '';
      input.focus();
    }

    function editCell(row, col) { selectCell(row, col); $('formula-input').select(); }

    async function submitFormula() {
      const input = $('formula-input'), { row, col } = selectedCell;
      showLoading();
      try {
        const data = await (await fetch('/api/cell', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ row, col, value: input.value }) })).json();
        if (data.success) updateGridFromResponse(data);
      } catch (e) { console.error('Network error:', e); }
      hideLoading();
      if (selectedCell.row < ROWS) selectCell(selectedCell.row + 1, selectedCell.col);
    }

    async function loadGrid() {
      try { updateGridFromResponse(await (await fetch('/api/grid')).json()); }
      catch (e) { console.error('Load error:', e); }
    }

    async function recalculateAll() {
      showLoading();
      try {
        const data = await (await fetch('/api/recalculate', { method: 'POST', headers: { 'Content-Type': 'application/json' } })).json();
        if (data.success) updateGridFromResponse(data);
      } catch (e) { console.error('Recalc error:', e); }
      hideLoading();
    }

    function updateGridFromResponse(data) {
      if (data.cells) {
        cells = {};
        for (const [key, d] of Object.entries(data.cells)) {
          cells[key] = d;
          const [row, col] = key.split(',').map(Number), el = getCellElement(row, col);
          if (el) {
            el.textContent = d.display || '';
            el.classList.remove('formula', 'error', 'boolean', 'text');
            if (d.formula) el.classList.add('formula');
            if (d.value?.tag === 'CellError') el.classList.add('error');
            else if (d.value?.tag === 'CellBoolean') el.classList.add('boolean');
            else if (d.value?.tag === 'CellText' && d.formula) el.classList.add('text');
          }
        }
      }
      if (data.stats) {
        $('stat-ops').textContent = data.stats.statsOperations;
        $('stat-tokens').textContent = '~' + data.stats.statsTokensEstimate;
        $('stat-cost').textContent = '~$' + data.stats.statsCostEstimate.toFixed(2);
      }
    }

    function showLoading() { $('loading').classList.add('active'); }
    function hideLoading() { $('loading').classList.remove('active'); }
    function showAbout() { $('about-modal').classList.add('active'); }
    function hideAbout() { $('about-modal').classList.remove('active'); }

    document.addEventListener('keydown', e => {
      if (document.activeElement.id === 'formula-input') {
        if (e.key === 'Escape') { exitPointMode(); document.activeElement.blur(); }
        if (isInPointMode && e.ctrlKey && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) { e.preventDefault(); navigateAndInsertRef(e.key, e.shiftKey); }
        return;
      }
      const { row, col } = selectedCell;
      if (e.shiftKey && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) { e.preventDefault(); extendSelection(e.key); return; }
      switch (e.key) {
        case 'ArrowUp': if (row > 1) selectCell(row - 1, col); e.preventDefault(); break;
        case 'ArrowDown': if (row < ROWS) selectCell(row + 1, col); e.preventDefault(); break;
        case 'ArrowLeft': if (col > 1) selectCell(row, col - 1); e.preventDefault(); break;
        case 'ArrowRight': if (col < COLS) selectCell(row, col + 1); e.preventDefault(); break;
        case 'Enter': $('formula-input').focus(); e.preventDefault(); break;
        case 'Escape': if (selectedRange) { selectedRange = null; clearSelectionVisual(); updateCellRefDisplay(); } break;
      }
    });

    function extendSelection(key) {
      if (!selectedRange) selectedRange = { startRow: selectedCell.row, startCol: selectedCell.col, endRow: selectedCell.row, endCol: selectedCell.col };
      if (key === 'ArrowUp' && selectedRange.endRow > 1) selectedRange.endRow--;
      else if (key === 'ArrowDown' && selectedRange.endRow < ROWS) selectedRange.endRow++;
      else if (key === 'ArrowLeft' && selectedRange.endCol > 1) selectedRange.endCol--;
      else if (key === 'ArrowRight' && selectedRange.endCol < COLS) selectedRange.endCol++;
      dragStart = { row: selectedRange.startRow, col: selectedRange.startCol };
      dragEnd = { row: selectedRange.endRow, col: selectedRange.endCol };
      updateSelectionVisual();
      dragStart = dragEnd = null;
    }

    function navigateAndInsertRef(key, isShift) {
      if (!pointModeNavPosition) pointModeNavPosition = pointModeRangeStart ? { ...pointModeRangeStart } : { row: selectedCell.row, col: selectedCell.col };
      if (key === 'ArrowUp' && pointModeNavPosition.row > 1) pointModeNavPosition.row--;
      else if (key === 'ArrowDown' && pointModeNavPosition.row < ROWS) pointModeNavPosition.row++;
      else if (key === 'ArrowLeft' && pointModeNavPosition.col > 1) pointModeNavPosition.col--;
      else if (key === 'ArrowRight' && pointModeNavPosition.col < COLS) pointModeNavPosition.col++;
      if (pointModeNavPosition.row !== selectedCell.row || pointModeNavPosition.col !== selectedCell.col) insertCellReference(pointModeNavPosition.row, pointModeNavPosition.col, isShift);
    }

    init();
  </script>
</body>
</html>
