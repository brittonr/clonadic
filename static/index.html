<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ClonadSheet</title>
  <script src="https://unpkg.com/htmx.org@2.0.4"></script>
  <style>
    :root {
      --bg: #0a0a0a;
      --surface: #141414;
      --border: #2a2a2a;
      --text: #e0e0e0;
      --text-dim: #666;
      --accent: #3b82f6;
      --error: #ef4444;
      --success: #22c55e;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    .logo span {
      color: var(--accent);
    }

    .actions {
      display: flex;
      gap: 12px;
    }

    button {
      font-family: inherit;
      font-size: 13px;
      padding: 8px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s;
    }

    button:hover {
      background: var(--border);
      border-color: var(--text-dim);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
    }

    button.primary:hover {
      background: #2563eb;
    }

    .formula-bar {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .formula-bar label {
      color: var(--text-dim);
      font-size: 14px;
      font-style: italic;
    }

    .cell-ref {
      background: var(--bg);
      border: 1px solid var(--border);
      padding: 6px 12px;
      min-width: 60px;
      text-align: center;
      font-weight: 600;
      color: var(--accent);
    }

    #formula-input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      padding: 6px 12px;
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
    }

    #formula-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .spreadsheet-container {
      flex: 1;
      overflow: auto;
      padding: 0;
    }

    .spreadsheet {
      display: grid;
      grid-template-columns: 50px repeat(10, minmax(100px, 1fr));
      min-width: max-content;
    }

    .cell {
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      padding: 8px 12px;
      min-height: 36px;
      font-size: 13px;
      cursor: cell;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .cell:hover {
      background: rgba(59, 130, 246, 0.1);
    }

    .cell.selected {
      background: rgba(59, 130, 246, 0.2);
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.in-selection {
      background: rgba(59, 130, 246, 0.15);
    }

    .cell.selection-corner {
      outline: 2px solid var(--accent);
      outline-offset: -2px;
    }

    .cell.header {
      background: var(--surface);
      color: var(--text-dim);
      font-weight: 600;
      text-align: center;
      cursor: default;
    }

    .cell.header:hover {
      background: var(--surface);
    }

    .cell.row-header {
      background: var(--surface);
      color: var(--text-dim);
      text-align: center;
      font-weight: 600;
      cursor: default;
    }

    .cell.row-header:hover {
      background: var(--surface);
    }

    .cell.formula {
      color: var(--accent);
    }

    .cell.error {
      color: var(--error);
    }

    .cell.boolean {
      color: #a855f7;
      font-weight: 600;
    }

    .cell.text {
      color: var(--success);
    }

    .cell.loading {
      color: var(--text-dim);
      font-style: italic;
    }

    footer {
      background: var(--surface);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }

    .stats {
      display: flex;
      gap: 24px;
      color: var(--text-dim);
    }

    .stat {
      display: flex;
      gap: 6px;
    }

    .stat-value {
      color: var(--text);
    }

    .tagline {
      color: var(--text-dim);
      font-style: italic;
    }

    .loading-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 24px 32px;
      display: none;
      z-index: 1000;
    }

    .loading-indicator.active {
      display: block;
    }

    .loading-indicator .spinner {
      margin-bottom: 12px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .about-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .about-modal.active {
      display: flex;
    }

    .about-content {
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 32px;
      max-width: 600px;
      width: 90%;
    }

    .about-content h2 {
      margin-bottom: 16px;
      font-size: 20px;
    }

    .about-content p {
      margin-bottom: 12px;
      color: var(--text-dim);
      line-height: 1.6;
    }

    .about-content code {
      background: var(--bg);
      padding: 2px 6px;
      font-size: 13px;
    }

    .about-content .close {
      margin-top: 24px;
    }

    /* Autocomplete dropdown styles */
    .formula-bar {
      position: relative;
    }

    .autocomplete-container {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-top: none;
      max-height: 280px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .autocomplete-dropdown.active {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 2px;
      border-bottom: 1px solid var(--border);
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: rgba(59, 130, 246, 0.2);
    }

    .autocomplete-item.selected {
      outline: 1px solid var(--accent);
      outline-offset: -1px;
    }

    .autocomplete-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .autocomplete-text {
      font-weight: 600;
      color: var(--text);
    }

    .autocomplete-type {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .autocomplete-type.function {
      background: rgba(59, 130, 246, 0.3);
      color: var(--accent);
    }

    .autocomplete-type.cell {
      background: rgba(34, 197, 94, 0.3);
      color: var(--success);
    }

    .autocomplete-type.range {
      background: rgba(168, 85, 247, 0.3);
      color: #a855f7;
    }

    .autocomplete-desc {
      font-size: 12px;
      color: var(--text-dim);
    }

    .autocomplete-hint {
      padding: 6px 12px;
      font-size: 11px;
      color: var(--text-dim);
      background: var(--bg);
      border-top: 1px solid var(--border);
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">Clonad<span>Sheet</span></div>
    <div class="actions">
      <button onclick="recalculateAll()">Recalculate All</button>
      <button onclick="showAbout()">About</button>
    </div>
  </header>

  <div class="formula-bar">
    <label>fx</label>
    <div class="cell-ref" id="cell-ref">A1</div>
    <div class="autocomplete-container">
      <input type="text" id="formula-input" placeholder="Enter a value or formula (e.g., =SUM(A1:A5))" autocomplete="off">
      <div class="autocomplete-dropdown" id="autocomplete-dropdown">
        <div class="autocomplete-hint">Type = to start a formula, then type function names or cell references</div>
      </div>
    </div>
    <button onclick="submitFormula()">Enter</button>
  </div>

  <div class="spreadsheet-container">
    <div class="spreadsheet" id="spreadsheet">
      <!-- Header row -->
      <div class="cell header"></div>
      <div class="cell header">A</div>
      <div class="cell header">B</div>
      <div class="cell header">C</div>
      <div class="cell header">D</div>
      <div class="cell header">E</div>
      <div class="cell header">F</div>
      <div class="cell header">G</div>
      <div class="cell header">H</div>
      <div class="cell header">I</div>
      <div class="cell header">J</div>

      <!-- Data rows will be generated by JS -->
    </div>
  </div>

  <footer>
    <div class="stats">
      <div class="stat">Claude operations: <span class="stat-value" id="stat-ops">0</span></div>
      <div class="stat">Tokens: <span class="stat-value" id="stat-tokens">~0</span></div>
      <div class="stat">Est. cost: <span class="stat-value" id="stat-cost">~$0.00</span></div>
    </div>
    <div class="tagline">"Every formula evaluation is a prayer."</div>
  </footer>

  <div class="loading-indicator" id="loading">
    <div class="spinner">Claude is computing...</div>
  </div>

  <div class="about-modal" id="about-modal">
    <div class="about-content">
      <h2>ClonadSheet</h2>
      <p>A spreadsheet where Claude evaluates every formula.</p>
      <p>
        <code>=2+2</code> is a Claude API call.<br>
        <code>=SUM(A1:A5)</code> is a Claude API call.<br>
        <code>=A1*B1</code> is a Claude API call.
      </p>
      <p>
        Spreadsheet formulas are the bedrock of financial modeling.
        They must be deterministic. Same input, same output. Always.
      </p>
      <p>
        This spreadsheet uses a large language model to compute
        <code>=A1+B1</code>.
      </p>
      <p style="margin-top: 24px; font-style: italic;">
        "We did this because we could."
        <br>
        <span style="color: var(--text-dim);">- Jane Street Hackathon 2026</span>
      </p>
      <button class="close" onclick="hideAbout()">Close</button>
    </div>
  </div>

  <script>
    const ROWS = 20;
    const COLS = 10;

    let selectedCell = { row: 1, col: 1 };
    let cells = {};

    // Drag selection state
    let isDragging = false;
    let dragStart = null;
    let dragEnd = null;
    let selectedRange = null; // { startRow, startCol, endRow, endCol } or null for single cell

    // Autocomplete state
    let autocompleteSelectedIndex = -1;
    let autocompleteSuggestions = [];
    let autocompleteDebounceTimer = null;

    function init() {
      renderGrid();
      selectCell(1, 1);
      loadGrid();
      setupAutocomplete();
    }

    function setupAutocomplete() {
      const input = document.getElementById('formula-input');
      const dropdown = document.getElementById('autocomplete-dropdown');

      input.addEventListener('keydown', (e) => {
        if (dropdown.classList.contains('active') && autocompleteSuggestions.length > 0) {
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, autocompleteSuggestions.length - 1);
            updateAutocompleteSelection();
            return;
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, 0);
            updateAutocompleteSelection();
            return;
          }
          if (e.key === 'Tab' || (e.key === 'Enter' && autocompleteSelectedIndex >= 0)) {
            e.preventDefault();
            applyAutocompleteSuggestion(autocompleteSelectedIndex);
            return;
          }
          if (e.key === 'Escape') {
            hideAutocomplete();
            return;
          }
        }

        if (e.key === 'Enter') {
          hideAutocomplete();
          submitFormula();
        }
      });

      input.addEventListener('input', () => {
        clearTimeout(autocompleteDebounceTimer);
        autocompleteDebounceTimer = setTimeout(() => {
          fetchAutocompleteSuggestions(input.value);
        }, 100);
      });

      input.addEventListener('blur', () => {
        setTimeout(hideAutocomplete, 150);
      });

      input.addEventListener('focus', () => {
        if (input.value.startsWith('=')) {
          fetchAutocompleteSuggestions(input.value);
        }
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-container')) {
          hideAutocomplete();
        }
      });
    }

    async function fetchAutocompleteSuggestions(input) {
      if (!input.startsWith('=')) {
        hideAutocomplete();
        return;
      }

      try {
        const response = await fetch(`/api/autocomplete?input=${encodeURIComponent(input)}`);
        const data = await response.json();
        autocompleteSuggestions = data.suggestions || [];
        autocompleteSelectedIndex = autocompleteSuggestions.length > 0 ? 0 : -1;
        renderAutocompleteDropdown();
      } catch (error) {
        console.error('Autocomplete error:', error);
        hideAutocomplete();
      }
    }

    function renderAutocompleteDropdown() {
      const dropdown = document.getElementById('autocomplete-dropdown');

      if (autocompleteSuggestions.length === 0) {
        dropdown.innerHTML = '<div class="autocomplete-hint">Type function names (SUM, IF, AVERAGE) or cell references (A1, B2)</div>';
        dropdown.classList.add('active');
        return;
      }

      let html = '';
      autocompleteSuggestions.forEach((suggestion, index) => {
        const typeClass = suggestion.suggestionType === 'SuggestionFunction' ? 'function' :
                         suggestion.suggestionType === 'SuggestionCell' ? 'cell' : 'range';
        const typeLabel = suggestion.suggestionType === 'SuggestionFunction' ? 'fn' :
                         suggestion.suggestionType === 'SuggestionCell' ? 'cell' : 'range';
        const selected = index === autocompleteSelectedIndex ? 'selected' : '';

        html += `
          <div class="autocomplete-item ${selected}" data-index="${index}" onclick="applyAutocompleteSuggestion(${index})">
            <div class="autocomplete-main">
              <span class="autocomplete-text">${escapeHtml(suggestion.suggestionDisplay)}</span>
              <span class="autocomplete-type ${typeClass}">${typeLabel}</span>
            </div>
            <div class="autocomplete-desc">${escapeHtml(suggestion.suggestionDescription)}</div>
          </div>
        `;
      });

      html += '<div class="autocomplete-hint">Tab or Enter to select, Esc to close</div>';
      dropdown.innerHTML = html;
      dropdown.classList.add('active');
    }

    function updateAutocompleteSelection() {
      const items = document.querySelectorAll('.autocomplete-item');
      items.forEach((item, index) => {
        if (index === autocompleteSelectedIndex) {
          item.classList.add('selected');
          item.scrollIntoView({ block: 'nearest' });
        } else {
          item.classList.remove('selected');
        }
      });
    }

    function applyAutocompleteSuggestion(index) {
      if (index < 0 || index >= autocompleteSuggestions.length) return;

      const suggestion = autocompleteSuggestions[index];
      const input = document.getElementById('formula-input');
      const currentValue = input.value;

      const newValue = replaceLastToken(currentValue, suggestion.suggestionInsert);
      input.value = newValue;
      input.focus();

      hideAutocomplete();

      if (suggestion.suggestionType === 'SuggestionFunction') {
        setTimeout(() => fetchAutocompleteSuggestions(input.value), 50);
      }
    }

    function replaceLastToken(input, replacement) {
      const delimiters = '(),+-*/^&=<>: ';
      let lastDelimiterIndex = -1;

      for (let i = input.length - 1; i >= 0; i--) {
        if (delimiters.includes(input[i])) {
          lastDelimiterIndex = i;
          break;
        }
      }

      if (lastDelimiterIndex === -1) {
        return replacement;
      }

      return input.substring(0, lastDelimiterIndex + 1) + replacement;
    }

    function hideAutocomplete() {
      const dropdown = document.getElementById('autocomplete-dropdown');
      dropdown.classList.remove('active');
      autocompleteSelectedIndex = -1;
      autocompleteSuggestions = [];
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function renderGrid() {
      const spreadsheet = document.getElementById('spreadsheet');

      // Clear existing data rows (keep headers)
      const existingCells = spreadsheet.querySelectorAll('.cell:not(.header)');
      existingCells.forEach(cell => {
        if (!cell.classList.contains('header')) {
          cell.remove();
        }
      });

      // Generate rows
      for (let row = 1; row <= ROWS; row++) {
        // Row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'cell row-header';
        rowHeader.textContent = row;
        spreadsheet.appendChild(rowHeader);

        // Data cells
        for (let col = 1; col <= COLS; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.onmousedown = (e) => handleCellMouseDown(e, row, col);
          cell.onmouseenter = (e) => handleCellMouseEnter(e, row, col);
          cell.ondblclick = () => editCell(row, col);
          spreadsheet.appendChild(cell);
        }
      }

      // Global mouse up to end drag
      document.addEventListener('mouseup', handleMouseUp);
    }

    function handleCellMouseDown(e, row, col) {
      // Prevent text selection during drag
      e.preventDefault();

      isDragging = true;
      dragStart = { row, col };
      dragEnd = { row, col };
      selectedRange = null;

      selectCell(row, col);
    }

    function handleCellMouseEnter(e, row, col) {
      if (!isDragging || !dragStart) return;

      dragEnd = { row, col };
      updateSelectionVisual();
    }

    function handleMouseUp() {
      if (!isDragging) return;

      isDragging = false;

      if (dragStart && dragEnd) {
        const startRow = Math.min(dragStart.row, dragEnd.row);
        const endRow = Math.max(dragStart.row, dragEnd.row);
        const startCol = Math.min(dragStart.col, dragEnd.col);
        const endCol = Math.max(dragStart.col, dragEnd.col);

        // Only set selectedRange if more than one cell is selected
        if (startRow !== endRow || startCol !== endCol) {
          selectedRange = { startRow, startCol, endRow, endCol };
          updateCellRefDisplay();
        } else {
          selectedRange = null;
        }
      }
    }

    function updateSelectionVisual() {
      // Clear all selection classes
      document.querySelectorAll('.cell.in-selection, .cell.selection-corner').forEach(c => {
        c.classList.remove('in-selection', 'selection-corner');
      });

      if (!dragStart || !dragEnd) return;

      const startRow = Math.min(dragStart.row, dragEnd.row);
      const endRow = Math.max(dragStart.row, dragEnd.row);
      const startCol = Math.min(dragStart.col, dragEnd.col);
      const endCol = Math.max(dragStart.col, dragEnd.col);

      // Highlight all cells in range
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          const cell = getCellElement(r, c);
          if (cell) {
            cell.classList.add('in-selection');
          }
        }
      }

      // Mark corners for the selection outline
      const cornerCell = getCellElement(endRow, endCol);
      if (cornerCell) {
        cornerCell.classList.add('selection-corner');
      }

      // Update cell ref to show range
      if (startRow !== endRow || startCol !== endCol) {
        const rangeStr = `${colToLetter(startCol)}${startRow}:${colToLetter(endCol)}${endRow}`;
        document.getElementById('cell-ref').textContent = rangeStr;
      }
    }

    function updateCellRefDisplay() {
      if (selectedRange) {
        const { startRow, startCol, endRow, endCol } = selectedRange;
        const rangeStr = `${colToLetter(startCol)}${startRow}:${colToLetter(endCol)}${endRow}`;
        document.getElementById('cell-ref').textContent = rangeStr;
      } else {
        document.getElementById('cell-ref').textContent = colToLetter(selectedCell.col) + selectedCell.row;
      }
    }

    function clearSelectionVisual() {
      document.querySelectorAll('.cell.in-selection, .cell.selection-corner').forEach(c => {
        c.classList.remove('in-selection', 'selection-corner');
      });
    }

    function getSelectedCells() {
      if (!selectedRange) {
        return [{ row: selectedCell.row, col: selectedCell.col }];
      }

      const { startRow, startCol, endRow, endCol } = selectedRange;
      const result = [];
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          result.push({ row: r, col: c });
        }
      }
      return result;
    }

    function colToLetter(col) {
      let result = '';
      while (col > 0) {
        col--;
        result = String.fromCharCode(65 + (col % 26)) + result;
        col = Math.floor(col / 26);
      }
      return result;
    }

    function selectCell(row, col, clearRange = true) {
      // Deselect previous
      document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));

      // Clear range selection if requested
      if (clearRange) {
        selectedRange = null;
        clearSelectionVisual();
      }

      // Select new
      selectedCell = { row, col };
      const cell = getCellElement(row, col);
      if (cell) {
        cell.classList.add('selected');
      }

      // Update formula bar
      document.getElementById('cell-ref').textContent = colToLetter(col) + row;

      const cellData = cells[`${row},${col}`];
      const input = document.getElementById('formula-input');
      if (cellData && cellData.formula) {
        input.value = cellData.formula;
      } else if (cellData && cellData.display) {
        input.value = cellData.display;
      } else {
        input.value = '';
      }
      input.focus();
    }

    function editCell(row, col) {
      selectCell(row, col);
      document.getElementById('formula-input').select();
    }

    function getCellElement(row, col) {
      return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    }

    async function submitFormula() {
      const input = document.getElementById('formula-input');
      const value = input.value;
      const { row, col } = selectedCell;

      showLoading();

      try {
        const response = await fetch('/api/cell', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ row, col, value })
        });

        const data = await response.json();

        if (data.success) {
          updateGridFromResponse(data);
        } else {
          console.error('Error updating cell:', data);
        }
      } catch (error) {
        console.error('Network error:', error);
      }

      hideLoading();

      // Move to next row
      if (selectedCell.row < ROWS) {
        selectCell(selectedCell.row + 1, selectedCell.col);
      }
    }

    async function loadGrid() {
      try {
        const response = await fetch('/api/grid');
        const data = await response.json();
        updateGridFromResponse(data);
      } catch (error) {
        console.error('Error loading grid:', error);
      }
    }

    async function recalculateAll() {
      showLoading();

      try {
        const response = await fetch('/api/recalculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        const data = await response.json();

        if (data.success) {
          updateGridFromResponse(data);
          console.log(`Recalculated ${data.recalculated} cells`);
        }
      } catch (error) {
        console.error('Error recalculating:', error);
      }

      hideLoading();
    }

    function updateGridFromResponse(data) {
      if (data.cells) {
        cells = {};
        for (const [key, cellData] of Object.entries(data.cells)) {
          cells[key] = cellData;
          const [row, col] = key.split(',').map(Number);
          const cellEl = getCellElement(row, col);
          if (cellEl) {
            cellEl.textContent = cellData.display || '';
            cellEl.classList.remove('formula', 'error', 'boolean', 'text');
            if (cellData.formula) {
              cellEl.classList.add('formula');
            }
            if (cellData.value) {
              if (cellData.value.tag === 'CellError') {
                cellEl.classList.add('error');
              } else if (cellData.value.tag === 'CellBoolean') {
                cellEl.classList.add('boolean');
              } else if (cellData.value.tag === 'CellText' && cellData.formula) {
                cellEl.classList.add('text');
              }
            }
          }
        }
      }

      if (data.stats) {
        document.getElementById('stat-ops').textContent = data.stats.statsOperations;
        document.getElementById('stat-tokens').textContent = '~' + data.stats.statsTokensEstimate;
        document.getElementById('stat-cost').textContent = '~$' + data.stats.statsCostEstimate.toFixed(2);
      }
    }

    function showLoading() {
      document.getElementById('loading').classList.add('active');
    }

    function hideLoading() {
      document.getElementById('loading').classList.remove('active');
    }

    function showAbout() {
      document.getElementById('about-modal').classList.add('active');
    }

    function hideAbout() {
      document.getElementById('about-modal').classList.remove('active');
    }

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (document.activeElement.id === 'formula-input') {
        if (e.key === 'Escape') {
          document.activeElement.blur();
        }
        return;
      }

      const { row, col } = selectedCell;

      // Shift+Arrow for range selection
      if (e.shiftKey && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        extendSelection(e.key);
        return;
      }

      switch (e.key) {
        case 'ArrowUp':
          if (row > 1) selectCell(row - 1, col);
          e.preventDefault();
          break;
        case 'ArrowDown':
          if (row < ROWS) selectCell(row + 1, col);
          e.preventDefault();
          break;
        case 'ArrowLeft':
          if (col > 1) selectCell(row, col - 1);
          e.preventDefault();
          break;
        case 'ArrowRight':
          if (col < COLS) selectCell(row, col + 1);
          e.preventDefault();
          break;
        case 'Enter':
          document.getElementById('formula-input').focus();
          e.preventDefault();
          break;
        case 'Escape':
          // Clear range selection
          if (selectedRange) {
            selectedRange = null;
            clearSelectionVisual();
            updateCellRefDisplay();
          }
          break;
      }
    });

    function extendSelection(arrowKey) {
      // Initialize range if not started
      if (!selectedRange) {
        selectedRange = {
          startRow: selectedCell.row,
          startCol: selectedCell.col,
          endRow: selectedCell.row,
          endCol: selectedCell.col
        };
      }

      // Extend the end of the range
      switch (arrowKey) {
        case 'ArrowUp':
          if (selectedRange.endRow > 1) selectedRange.endRow--;
          break;
        case 'ArrowDown':
          if (selectedRange.endRow < ROWS) selectedRange.endRow++;
          break;
        case 'ArrowLeft':
          if (selectedRange.endCol > 1) selectedRange.endCol--;
          break;
        case 'ArrowRight':
          if (selectedRange.endCol < COLS) selectedRange.endCol++;
          break;
      }

      // Update visual using drag mechanism
      dragStart = { row: selectedRange.startRow, col: selectedRange.startCol };
      dragEnd = { row: selectedRange.endRow, col: selectedRange.endCol };
      updateSelectionVisual();
      dragStart = null;
      dragEnd = null;
    }

    init();
  </script>
</body>
</html>
